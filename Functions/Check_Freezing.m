function Check_Freezing(InputFiles)
%% Check_Freezing - A GUI to perform freezing detection.
%
% Uses the motion output from the tracking GUI and the original movie
% to extract freezing episodes and display the results. Parameters can
% then be adjusted to give the best results. The same parameters are
% usually usable for different animals in the same conditions.
%
%       - Uses a motion threshold to detect freezing episodes
%       - Allows to merge episodes closer than a defined gap
%       - Defines a minimum freezing duration
%       - Allows manual editing/removal of single episodes
%        (e.g. sometimes to remove grooming detected as freezing)
%
%   Output: a new variable in the .mat tracking file with the start/end
%   times of each freezing episode
%
% The current version has not been tested for compatibility and
% dependencies; in particular, it might not run under MATLAB versions
% older than R2018a. Also, unlike the tracking GUI, it needs the frames
% timestamps, that are currently either retrieved from the tracking
% file or a file generated by our acquisition system. This will soon be
% expanded to accommodate different systems.
%
% Future implementations/changes:
%       - Expand the manual
%       - Switch from function to class for more robustness and ease of
%         use on successive files
%       - Make the overall code less dependent on the recording system
%       - Use the calibration option from the tracking GUI to get an even
%         more absolute freezing threshold (here it is influenced by the
%         real pixel size, that depends on the camera distance)
%       - Take into account potential differences in screen
%         resolutions/sizes
%       - Add inputs checking
%       - Adjust some parameters to get a smooth browsing (some movies
%         have ridiculous FPS and resolution that are too heavy to handle
%         like this)
%
%     Copyright (C) 2019 Jérémy Signoret-Genest, DefenseCircuitsLab
%
%     This program is free software: you can redistribute it and/or modify
%     it under the terms of the GNU General Public License as published by
%     the Free Software Foundation, either version 3 of the License, or
%     (at your option) any later version.
%
%     This program is distributed in the hope that it will be useful,
%     but WITHOUT ANY WARRANTY; without even the implied warranty of
%     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%     GNU General Public License for more details.
%
%     You should have received a copy of the GNU General Public License
%     along with this program.  If not, see <https://www.gnu.org/licenses/>.

if nargin == 0,

    Experimenters = DataBase.Lists.GetList('Experimenters');
    IndxExpe = strcmpi(Experimenters(:,2),getenv('username'));

    % File input or folder input?
    Answer = questdlg('What do you want to process?','Please choose...','Single file','Folder','Single file');
    switch Answer
        case 'Single file'
            if any(IndxExpe)
                CurrentExperimenter = Experimenters(IndxExpe,1);
                [FileName,FilePath] = uigetfile(['G:\' CurrentExperimenter{1} '\Data\*.mp4;*.avi;*.mj2'],'Please choose a folder...');
            else
                [FileName,FilePath] = uigetfile(['G:\*.mp4;*.avi;*.mj2'],'Please choose a folder...');
            end
            if FileName == 0
                warning('No file selected. Aborting.')
                return
            end
            InputFiles = fullfile(FilePath,FileName);
        case 'Folder'
            if any(IndxExpe)
                CurrentExperimenter = Experimenters(IndxExpe,1);
                [Path] = uigetdir(['G:\' CurrentExperimenter{1} '\Data\'],'Please choose a folder...');
            else
                [Path] = uigetdir(['G:\'],'Please choose a folder...');
            end
            if Path == 0
                warning('No folder was selected. Aborting.')
                return
            end

            Files = dir([Path '\**\*_Tracking.mat']);
            if ~isempty(Files)
                InputFiles = arrayfun(@(x) fullfile(Files(x).folder,Files(x).name),1:numel(Files),'UniformOutput',false);
            else
                warning('No matching files found. Aborting.')
                return
            end
    end
end
if ~iscell(InputFiles),
    InputFiles = {InputFiles};
end
set(0,'Units','pixels')

for ir = 1 : numel(InputFiles),
    OnlineReading = true;
    MergeThreshold = 0.2;
    FreezingMinTime = 2;
    ThresholdMM = 1.5;
    SmoothMM = 3;
    RemovedWindows = []; 
    Subs = {'SubMM','SubFreezing'};
    Selected = [];
    for S = 1 : numel(Subs)
        Handles.FillRemovedWindows.(Subs{S}) = [];
    end
    [PathIR,NameIR,Ext] = fileparts(InputFiles{ir});
    if contains(NameIR,'_Tracking') && strcmpi(Ext,'.mat')
        NameIR = strsplit(NameIR,'_Tracking');
        NameIR = NameIR{1};
        Ext = '.avi'; % By default
    end
    if contains(InputFiles{ir},'_IR')
        MovieType = 'Thermal';
        [~,~,MovieExt] = fileparts(InputFiles{ir});
        NameIR = NameIR(1:end-3);
        MovieFileName = [PathIR,'\',NameIR,'_IR' Ext];
    else
        MovieType = 'RGB';
        MovieFileName = [PathIR,'\',NameIR, Ext];
    end

    %% Retrieve data
    disp(['Processing file ' num2str(ir) ' out of ' num2str(numel(InputFiles)) '...'])
    TrackingLog = [PathIR,'\',NameIR,'_Tracking.mat'];
    Tracking = load(TrackingLog);
    %     numFrames = Tracking.(MovieType).FramesNum;
    if ~isfield(Tracking,(MovieType))
        warning(['There is no ' MovieType 'tracking for '  NameIR '. Skipping.'])
        continue
    end
    if isfield(Tracking.(MovieType),'Freezing')
        Answer = questdlg(['Freezing was already extracted for '  NameIR  '. Do you want to reextract it?'],'Please choose...','Yes, continue.','No, skip.','No, skip.');
        if strcmpi(Answer,'No, skip.')
            continue
        end
    end
    Contour = Tracking.(MovieType).Contour;
    Center_GF = Tracking.(MovieType).Center;
    if exist(MovieFileName,'file')~=2 && strcmpi(MovieType,'RGB')
        Ext = '.mp4';
        MovieFileName = [PathIR,'\',NameIR, Ext];
    end
    Frame0 = VideoReader(MovieFileName);
    if isfield(Tracking.(MovieType),'MovieTimes')
        FrameTimes = Tracking.(MovieType).MovieTimes;
    else % Legacy
        FrameTimes = (1/Frame0.FrameRate : 1/Frame0.FrameRate : Frame0.Duration)-1/Frame0.FrameRate;
    end
    if ~isfield(Tracking.(MovieType),'Times')
        if strcmpi(MovieType,'RGB'),
            MM_File = [PathIR '\' NameIR '.DVT'];
            TSQ_File = dir([PathIR filesep '*.tsq']);
            if exist(MM_File,'file')==2
                DVTRead = csvread(MM_File);
                Times = DVTRead(:,2);
            elseif isfield(Tracking.(MovieType),'MovieTimes'), % Legacy
                Times = Tracking.(MovieType).MovieTimes;
            elseif ~isempty(TSQ_File)
                ReadTDT = TDTbin2mat(PathIR);
                if isfield(ReadTDT.epocs,'Cam1')
                    Times = ReadTDT.epocs.Cam1.onset;
                    Tracking.(MovieType).Times = Times;
                elseif isfield(ReadTDT.epocs,'Cam')
                    Times = ReadTDT.epocs.Cam.onset;
                    Tracking.(MovieType).Times = Times;
                else
                    Times = FrameTimes;
                    warning('No timestamps file found. Using movies'' framerate and assuming it is constant.')
                end
            else
                Times = FrameTimes;
                warning('No timestamps file found. Using movies'' framerate and assuming it is constant.')
            end
        else
            error('No time information found.');
        end
    else
        Times = Tracking.(MovieType).Times;
    end

    if isfield(Tracking.(MovieType),'RemovedRanges')
        % Apply exclusion ranges to motion and speed
        if ~isempty(Tracking.(MovieType).RemovedRanges)
            RemovedWindows = Tracking.(MovieType).RemovedRanges;
        end
    end
    % Legacy
    if strcmpi(MovieType,'Thermal') && ~strcmpi(MovieExt,'.mj2') ,
        Times = (round(Times-Times(1))/10)/100;
    end
    if isempty(Times) && ~strcmpi(MovieType,'Thermal')
        Times = FrameTimes;
        warning('No timestamps file found. Using movies'' framerate and assuming it is constant.')
    end

    %     if ~OnlineReading,
    %         disp(newline)
    %         disp('Retrieving all frames...')
    %         Frames = cell(numFrames,1);
    %         parfor F = 1 : numFrames-1,
    %             FrameF = Frame0;
    %             FrameF.CurrentTime = FrameTimes(F);
    %             Frames{F} = FrameF.readFrame;
    %         end
    %     end

    % Get freezing events
    MotionMeasure = Tracking.(MovieType).MotionMeasure;
    if numel(MotionMeasure) ~= numel(Times),
        MotionMeasure = [NaN;MotionMeasure]; % Legacy
    end
    MotionMeasure(isnan(MotionMeasure)) = 0;
    Contour(isinf(MotionMeasure)) = {[NaN;NaN]};
    Contour(cellfun('isempty', Contour)) = {[NaN;NaN]};
    MotionMeasure(isinf(MotionMeasure)) = 100;

    LoadedFE = false;
    if isfield(Tracking.(MovieType),'Freezing'),
        if isfield(Tracking.(MovieType).Freezing,'Ranges'),
            if ~isempty(Tracking.(MovieType).Freezing.Ranges),
                FreezingEpisodes = Tracking.(MovieType).Freezing.Ranges;
                ThresholdMM = Tracking.(MovieType).Freezing.MotionMeasureThreshold;
                MergeThreshold = Tracking.(MovieType).Freezing.MergingThreshold;
                FreezingMinTime = Tracking.(MovieType).Freezing.Duration;
                SmoothMM = Tracking.(MovieType).Freezing.Smoothing;
                LoadedFE = true;
            end
        end
    end
    if ~LoadedFE
        FindIndex = find(Smooth(MotionMeasure,SmoothMM)<ThresholdMM);
        FreezingEpisodes = FindContinuousRange(FindIndex);
        FreezingEpisodes = FindIndex(FreezingEpisodes(:,[1 2]));
        FreezingEpisodes = Times(FreezingEpisodes);
        % Merging
        for KF = 2 : numel(FreezingEpisodes(:,1))
            if (FreezingEpisodes(KF,1)-FreezingEpisodes(KF-1,2))<MergeThreshold,
                FreezingEpisodes(KF-1,2) = FreezingEpisodes(KF,2);
                FreezingEpisodes(KF,1) = FreezingEpisodes(KF-1,1);
            end
        end
        FreezingEpisodesLength = (FreezingEpisodes(:,2)-FreezingEpisodes(:,1));
        FreezingEpisodes(FreezingEpisodesLength<=FreezingMinTime,:) = [];

        [~,FreezingEpisodesIndex] = unique(FreezingEpisodes(:,1));
        FreezingEpisodes = FreezingEpisodes(FreezingEpisodesIndex,:);
    else
        % Legacy to correct some files that were initially heavily edited
        % manually before the overlap detection was implemented for manual
        % edition
        % Check for overlaps with neighbouring episodes
        DeletionIndx = [];
        for SelEp = 1 : size(FreezingEpisodes,1)-1
            if FreezingEpisodes(SelEp,2)>=FreezingEpisodes(SelEp+1,1)
                FreezingEpisodes(SelEp+1,1) = FreezingEpisodes(SelEp,1);
                DeletionIndx = [DeletionIndx;SelEp];
            end
        end
        if ~isempty(DeletionIndx)
            warning('Manual edition has been performed with an older version of the tool. Some episodes were manually overlapped and have now been merged.')
            FreezingEpisodes(DeletionIndx,:) = [];
        end
    end
    OriginalEpisodes = FreezingEpisodes;


    %% Prepare figure and UI
    Scrsz = get(0,'ScreenSize');
    Fig = figure('Position',[Scrsz(3)/10 50 4/5*Scrsz(3) Scrsz(4)-150]);
    SubMovie = subplot('Position',[0.075 0.4290 0.4167 0.5161]);
    Handles.SubMM = subplot('Position',[0.075 2*(1-0.9451) 1-0.0449-0.075 1-4*(1-0.9451)-0.5161]);
    Handles.SubFreezing = subplot('Position',[Handles.SubMM.Position(1)  Handles.SubMM.Position(2)+Handles.SubMM.Position(4)  Handles.SubMM.Position(3) 0.5*(1-0.9451)]);
    MouseID = uicontrol('Style','text','String',NameIR,'FontSize',14,'FontName','Arial','FontWeight','bold',...
        'Units','Normalized','Position',[0.075 0.95 0.4 0.025],'HorizontalAlignment','left');
    LockedZoom = uicontrol('Style','checkbox','String',' Lock Y-Axis','Value',true,'FontSize',16,'FontName','Arial','FontWeight','bold',...
        'Callback',@YZoom,'Units','Normalized','Position',[0.55 0.71 0.15 0.025]);
    CancelAdjustment = uicontrol('Style','pushbutton','String','Cancel last adjustment','FontSize',16,'FontName','Arial','FontWeight','bold',...
        'Callback',@RevertLastAdjustment,'Units','Normalized','Position',[0.55 0.525 0.175 0.05]);
    CancelDeletion = uicontrol('Style','pushbutton','String','Cancel last deletion','FontSize',16,'FontName','Arial','FontWeight','bold',...
        'Callback',@CancelLastDeletion,'Units','Normalized','Position',[0.55 0.585 0.175 0.05]);
    Delete = uicontrol('Style','pushbutton','String','Delete selected episode','FontSize',16,'FontName','Arial','FontWeight','bold',...
        'Callback',@DeleteEpisode,'Units','Normalized','Position',[0.55 0.645 0.175 0.05]);
    PlayButton = uicontrol('Style','pushbutton','String','Play','FontSize',16,'FontName','Arial','FontWeight','bold',...
        'Callback',@SetPlay,'Units','Normalized','Position',[0.62 0.45 0.07 0.05]);
    PauseButton = uicontrol('Style','pushbutton','String','Pause','FontSize',16,'FontName','Arial','FontWeight','bold',...
        'Callback',@PauseMovie,'Units','Normalized','Position',[0.69 0.45 0.07 0.05]);
    DecreaseRateButton = uicontrol('Style','pushbutton','String','Slower','FontSize',16,'FontName','Arial','FontWeight','bold',...
        'Callback',@DecreaseFrameRate,'Units','Normalized','Position',[0.55 0.45 0.07 0.05]);
    IncreaseRateButton = uicontrol('Style','pushbutton','String','Faster','FontSize',16,'FontName','Arial','FontWeight','bold',...
        'Callback',@IncreaseFrameRate,'Units','Normalized','Position',[0.76 0.45 0.07 0.05]);
    ThresholdEdit = uicontrol('Style','edit','String',num2str(ThresholdMM),'FontSize',16,'FontName','Arial','FontWeight','bold',...
        'Callback',@EditThreshold,'Units','Normalized','Position',[0.55 0.80 0.05 0.04]);
    ThresholdLegend = uicontrol('Style','text','String','Freezing threshold','FontSize',14,'FontName','Arial','FontWeight','bold',...
        'Units','Normalized','Position',[0.55 0.85 0.15 0.03],'HorizontalAlignment','left');
    ThresholdDrag = uicontrol('Style','pushbutton','String','Drag','FontSize',16,'FontName','Arial','FontWeight','bold',...
        'Callback',@DragThreshold,'Units','Normalized','Position',[0.55 0.75 0.05 0.04],'HorizontalAlignment','left');
    ThresholdEditSet = uicontrol('Style','pushbutton','String','Set','FontSize',16,'FontName','Arial','FontWeight','bold',...
        'Callback',@EditThresholdSet,'Units','Normalized','Position',[0.6005 0.80 0.05 0.04],'HorizontalAlignment','left');
    MergeThresholdEdit = uicontrol('Style','edit','String',num2str(MergeThreshold),'FontSize',16,'FontName','Arial','FontWeight','bold',...
        'Callback',@MergeEditThreshold,'Units','Normalized','Position',[0.7 0.80 0.05 0.04]);
    MergeThresholdLegend = uicontrol('Style','text','String','Merging threshold (s)','FontSize',14,'FontName','Arial','FontWeight','bold',...
        'Units','Normalized','Position',[0.7 0.85 0.15 0.03],'HorizontalAlignment','left');
    MergeThresholdEditSet = uicontrol('Style','pushbutton','String','Set','FontSize',16,'FontName','Arial','FontWeight','bold',...
        'Callback',@MergeEditThresholdSet,'Units','Normalized','Position',[0.7505 0.80 0.05 0.04],'HorizontalAlignment','left');
    MinEpisodeLegend = uicontrol('Style','text','String','Minimum (s)','FontSize',14,'FontName','Arial','FontWeight','bold',...
        'Units','Normalized','Position',[0.85 0.85 0.15 0.03],'HorizontalAlignment','left');
    MinEpisodeEdit = uicontrol('Style','edit','String',num2str(FreezingMinTime),'FontSize',16,'FontName','Arial','FontWeight','bold',...
        'Callback',@EditMinEpisode,'Units','Normalized','Position',[0.85 0.80 0.05 0.04]);
    MinEpisodeEditSet = uicontrol('Style','pushbutton','String','Set','FontSize',16,'FontName','Arial','FontWeight','bold',...
        'Callback',@EditMinEpisodeSet,'Units','Normalized','Position',[0.9005 0.80 0.05 0.04],'HorizontalAlignment','left');

    ValidateButton = uicontrol('Style','pushbutton','String','Validate','FontSize',16,'FontName','Arial','FontWeight','bold',...
        'Callback',@Exit,'Units','Normalized','Position',[0.8850 0.01 0.0700 0.0500],'HorizontalAlignment','left');

    AddRange = uicontrol('Style','pushbutton','String','Add exclusion range','FontSize',16,'FontName','Arial','FontWeight','bold',...
        'Callback',@AddRangeCB,'Units','Normalized','Position',[0.75 0.645 0.175 0.05],'HorizontalAlignment','center');
    DeleteRange = uicontrol('Style','pushbutton','String','Delete selected range','FontSize',16,'FontName','Arial','FontWeight','bold',...
        'Callback',@DeleteRangeCB,'Units','Normalized','Position',[0.75 0.585 0.175 0.05],'HorizontalAlignment','center');


    %% Initialize
    %     if ~OnlineReading,
    %         ImFrame = image(Frames{1},'Parent',SubMovie);
    %     else
    if strcmpi(MovieType,'Thermal'),
        TempFrame = Frame0.readFrame;
        ImFrame = imagesc(TempFrame(:,:,1),'Parent',SubMovie);
        HW = load('HotWhite');
        SubMovie.Colormap = HW.HotWhite;
        SubMovie.CLim = [25 175];
    else
        ImFrame = image(Frame0.readFrame,'Parent',SubMovie);
    end
    %     end
    hold(SubMovie,'on')
    drawnow
    ContourPlot = plot(Contour{1}(1,:),Contour{1}(2,:),'g','LineWidth',2.5,'Parent',SubMovie);
    uistack(ContourPlot,'top')
    CenterPlot = plot(Center_GF(1,1),Center_GF(1,2),'+k','LineWidth',2.5,'MarkerSize',5,'Parent',SubMovie);
    uistack(CenterPlot,'top')
    SpeedText = text(0.9*Frame0.Width,0.95*Frame0.Height,'x1','FontSize',22,'FontName','Arial','FontWeight','bold','Color','g','Parent',SubMovie);
    uistack(SpeedText,'top')
    if OnlineReading,
        TimeText = text(0.05*Frame0.Width,0.95*Frame0.Height,num2str(Times(1)),'FontSize',22,'FontName','Arial','FontWeight','bold','Color','g','Parent',SubMovie);
    end
    uistack(TimeText,'top')
    hold(SubMovie,'off')
    SubMovie.XColor = 'none';
    SubMovie.YColor = 'none';
    plot(Times,Smooth(MotionMeasure,SmoothMM),'LineWidth',1.5,'Parent', Handles.SubMM);
    hold( Handles.SubMM,'on')
    drawnow
    YlimMM = Handles.SubMM.YLim;
    % Plot events (opto, sound, shocks)
    %     if
    %         pause(0.025)
    %         TrialTimes =  [180;350;500];
    %         FillCheck = arrayfun(@(x) fill([TrialTimes(x) TrialTimes(x)+10 TrialTimes(x)+10 TrialTimes(x)],[0 0 500 500],[0.85 0.85 0.85],'EdgeColor','none','Parent', Handles.SubMM),1:numel(TrialTimes));
    %         drawnow
    %         pause(0.025)
    %         uistack(FillCheck,'bottom');
    %     end

    % Prepare a hidden plot for the threshold
    ThresholdLine = plot(Times([2 end]),[1 1],'Color','none','LineWidth',1.5,'Parent', Handles.SubMM);
    PimpAxis( Handles.SubMM,'xlabel','Time(s)','ylabel','Motion Measure')
    Handles.SubMM.XLim = [-5 Times(end)];
    LineCurrentTime = plot([0 0],[0 500],'LineWidth',2.5,'Parent', Handles.SubMM,'ButtonDownFcn',@TimeLine);
    Handles.SubMM.YLim = YlimMM;
    Handles.Min.SubMM = YlimMM(1);
    Handles.Max.SubMM = YlimMM(2);
    linkaxes([Handles.SubMM Handles.SubFreezing],'x')
    hold( Handles.SubFreezing,'on');
    FreezingHandles = arrayfun(@(x) plot([FreezingEpisodes(x,1) FreezingEpisodes(x,2)],[0 0],'k','LineWidth',3,'Parent', Handles.SubFreezing,'Tag',num2str(x),'ButtonDownFcn',@FreezingEdit),1:numel(FreezingEpisodes(:,1)));
    Handles.SubFreezing.XColor = 'none';
    Handles.SubFreezing.YColor = 'none';
    Handles.SubFreezing.YLim = [-0.5 0.5];
    Handles.Min.SubFreezing = -0.5;
    Handles.Max.SubFreezing = 0.5;
    drawnow

    for ST = 1 : numel(Subs)
        delete( Handles.FillRemovedWindows.(Subs{ST}))
        if ~isempty(RemovedWindows)
            Handles.FillRemovedWindows.(Subs{ST}) = arrayfun(@(x) fill([RemovedWindows(x,1) RemovedWindows(x,2) RemovedWindows(x,2) RemovedWindows(x,1)], [ Handles.Min.(Subs{ST})   Handles.Min.(Subs{ST})   Handles.Max.(Subs{ST})   Handles.Max.(Subs{ST})],[0.85 0.85 0.9],'EdgeColor','none','Parent',Handles.(Subs{ST}),'ButtonDownFcn',@(src,evt)SelectWindow(src,evt),'Tag',num2str(x)),1:numel(RemovedWindows(:,1)));
            uistack( Handles.FillRemovedWindows.(Subs{ST}),'bottom')
        end
    end

    drawnow
   Zoom.SubFreezing = zoom( Handles.SubFreezing);
   Zoom.SubFreezing.Motion = 'horizontal';
   Zoom.SubFreezing.ActionPostCallback = @EvaluateWindow;
   Zoom.SubMM = zoom( Handles.SubMM);
   Zoom.SubMM.Motion = 'horizontal';
   Zoom.SubMM.ActionPostCallback = @EvaluateWindow;
    Edition = false;
    DeletionIndex = [];
    SelectedEpisode = [];
    LeftLimit = [];
    RightLimit = [];
    Dragging = false;
    AdjustedRanges = [];
    CurrentTime = 0;
    Play = false;
    PrePlayState = [];
    FrameRate = Frame0.FrameRate;
    ShiftTimeLine = 0.2;
    UpToDate = true;
    drawnow
    ReProcessFreezing;
    waitfor(Fig);
end


    function YZoom(src,~)
        if src.Value==0,
           Zoom.SubMM.Motion = 'both';
        else
           Zoom.SubMM.Motion = 'horizontal';
        end
    end

    function IncreaseFrameRate(~,~)
        FrameRate = FrameRate*2;
        SpeedText.String = ['x' num2str(round(FrameRate/Frame0.FrameRate*10)/10)];
        uistack(SpeedText,'top')
        drawnow
    end

    function SetPlay(~,~)
        Play = true;
        PlayMovie;
    end

    function DecreaseFrameRate(~,~)
        FrameRate = FrameRate/2;
        SpeedText.String = ['x' num2str(round(FrameRate/Frame0.FrameRate*10)/10)];
        uistack(SpeedText,'top')
        drawnow
    end

    function FreezingEdit(src,~)
        % Check if an episode is being edited
        if ~Edition
            % Make sure the playing has stopped
            PrePlayState = Play;
            Play = false;
            % Get episode index
            SelectedEpisode = str2double(src.Tag);
            % Change line appearence
            src.LineWidth = 2.5;
            src.Color = [0.85,0.33,0.10];
            % Change callback
            src.ButtonDownFcn = @FreezingEndEdit;
            % Draw bars on limits
            LeftLimit = plot([FreezingEpisodes(SelectedEpisode,1) FreezingEpisodes(SelectedEpisode,1)],[-0.25 0.25],'k','LineWidth',2,'ButtonDownFcn',@DragLimitLeft);
            RightLimit = plot([FreezingEpisodes(SelectedEpisode,2) FreezingEpisodes(SelectedEpisode,2)],[-0.25 0.25],'k','LineWidth',2,'ButtonDownFcn',@DragLimitRight);
            % Set status
            Edition = true;
        end
    end

    function DragLimitLeft(~,~)
        if ~Dragging,
            Dragging = true;
            Fig.WindowButtonMotionFcn = @MovingCursorLeft;
            Fig.WindowButtonUpFcn = @DragLimitLeft;
        else
            Dragging = false;
            Fig.WindowButtonMotionFcn = [];
            Fig.WindowButtonUpFcn = [];
            AdjustedRanges = [AdjustedRanges;SelectedEpisode];
            FreezingEpisodes(SelectedEpisode,1) = LeftLimit.XData(1);
        end
    end

    function MovingCursorLeft(~,~)
        CurrentCursor = Handles.SubFreezing.CurrentPoint;
        if CurrentCursor(1)<FreezingEpisodes(SelectedEpisode,2),
            LeftLimit.XData = [CurrentCursor(1) CurrentCursor(1)];
            FreezingHandles(SelectedEpisode).XData(1) = CurrentCursor(1);
        end
    end
    function DragLimitRight(~,~)
        if ~Dragging,
            Dragging = true;
            Fig.WindowButtonMotionFcn = @MovingCursorRight;
            Fig.WindowButtonUpFcn = @DragLimitRight;
        else
            Dragging = false;
            Fig.WindowButtonMotionFcn = [];
            Fig.WindowButtonUpFcn = [];
            FreezingEpisodes(SelectedEpisode,2) = RightLimit.XData(1);
        end
    end

    function MovingCursorRight(~,~)
        CurrentCursor = Handles.SubFreezing.CurrentPoint;
        if CurrentCursor(1)>FreezingEpisodes(SelectedEpisode,1),
            RightLimit.XData = [CurrentCursor(1) CurrentCursor(1)];
            FreezingHandles(SelectedEpisode).XData(2) = CurrentCursor(1);
        end
    end

    function RevertLastAdjustment(~,~)
        if ~isempty(AdjustedRanges),
            FreezingEpisodes(AdjustedRanges(end),:) = OriginalEpisodes(AdjustedRanges(end),:);
            FreezingHandles(AdjustedRanges(end)).XData = OriginalEpisodes(AdjustedRanges(end),:);
            AdjustedRanges(end) = [];
        end
    end

    function FreezingEndEdit(src,~)
        % Revert appearence
        src.LineWidth = 3;
        src.Color = 'k';
        % Set status
        Edition = false;
        AdjustedRanges = [AdjustedRanges;SelectedEpisode];
        FreezingEpisodes(SelectedEpisode,1) = LeftLimit.XData(1);
        FreezingEpisodes(SelectedEpisode,2) = RightLimit.XData(1);
        % Check for overlaps with neighbouring episodes
        DeletionIndx = [];
        if SelectedEpisode>1
            if FreezingEpisodes(SelectedEpisode,1)<FreezingEpisodes(SelectedEpisode-1,2)
                FreezingEpisodes(SelectedEpisode,1) = FreezingEpisodes(SelectedEpisode-1,1);
                DeletionIndx = [DeletionIndx;SelectedEpisode-1];
            end
        end
        if SelectedEpisode<size(FreezingEpisodes,1)
            if FreezingEpisodes(SelectedEpisode,2)>FreezingEpisodes(SelectedEpisode+1,1)
                FreezingEpisodes(SelectedEpisode,2) = FreezingEpisodes(SelectedEpisode+1,2);
                DeletionIndx = [DeletionIndx;SelectedEpisode+1];
            end
        end
        if ~isempty(DeletionIndx)
            FreezingEpisodes(DeletionIndx,:) = [];
        end

        SelectedEpisode = [];
        % Remove bars on limits
        delete(LeftLimit)
        delete(RightLimit)
        % Change callback
        src.ButtonDownFcn = @FreezingEdit;
        % Restore playing state
        Play = PrePlayState;
    end

    function DeleteEpisode(~,~)
        if ~isempty(SelectedEpisode),
            % Remove bars on limits
            delete(LeftLimit)
            delete(RightLimit)
            FreezingHandles(SelectedEpisode).LineWidth = 3;
            FreezingHandles(SelectedEpisode).ButtonDownFcn = [];
            FreezingHandles(SelectedEpisode).Color = 'none';
            DeletionIndex = [DeletionIndex,SelectedEpisode];
            % Set status
            Edition = false;
            SelectedEpisode = [];
            % Restore playing state
            Play = PrePlayState;
        end
    end

    function CancelLastDeletion(~,~)
        if ~isempty(DeletionIndex),
            FreezingHandles(DeletionIndex(end)).Color = 'k';
            FreezingHandles(DeletionIndex(end)).ButtonDownFcn = @FreezingEdit;
            DeletionIndex(end) = [];
        end
    end


    function AddRangeCB(~,~)
        D = drawrectangle( Handles.SubMM);
        NewWindow = [D.Position(1),D.Position(1)+D.Position(3)];
        delete(D)
        RemovedWindows = sort([RemovedWindows; NewWindow]);

        % Find and remove potential overlaps
        IndxRmv = round(RemovedWindows*1000);
        Break = false;
        if numel(IndxRmv(:,1))>1
            while ~Break
                Break = true;
                Reloop = false;
                % Loop through the ranges
                for R = 1 : numel(IndxRmv(:,1)),
                    for S = 1 : numel(IndxRmv(:,1)),
                        if S~=R,
                            if ~Reloop
                                % Find intersections
                                Intrsct = intersect(IndxRmv(R,1):IndxRmv(R,2),IndxRmv(S,1):IndxRmv(S,2));
                                if ~isempty(Intrsct),
                                    % Extend ranges
                                    Min = min([IndxRmv(R,1) IndxRmv(S,1)]);
                                    IndxRmv(R,1) = Min;
                                    IndxRmv(S,1) = Min;
                                    Min = min([RemovedWindows(R,1) RemovedWindows(S,1)]);
                                    RemovedWindows(R,1) = Min;
                                    RemovedWindows(S,1) = Min;
                                    Max = max([IndxRmv(R,2) IndxRmv(S,2)]);
                                    IndxRmv(R,2) = Max;
                                    IndxRmv(S,2) = Max;
                                    Max = max([RemovedWindows(R,2) RemovedWindows(S,2)]);
                                    RemovedWindows(R,2) = Max;
                                    RemovedWindows(S,2) = Max;
                                    Break = false;
                                    RemovedWindows = unique(RemovedWindows,'rows');
                                    IndxRmv = unique(IndxRmv,'rows');
                                    Reloop = true;
                                end
                            end
                        end
                    end
                end
            end
        end
        RemovedWindows = sort(unique(RemovedWindows,'rows'));

        for ST = 1 : numel(Subs)
            delete( Handles.FillRemovedWindows.(Subs{ST}))
            Handles.FillRemovedWindows.(Subs{ST}) = arrayfun(@(x) fill([RemovedWindows(x,1) RemovedWindows(x,2) RemovedWindows(x,2) RemovedWindows(x,1)], [ Handles.Min.(Subs{ST})   Handles.Min.(Subs{ST})   Handles.Max.(Subs{ST})   Handles.Max.(Subs{ST})],[0.85 0.85 0.9],'EdgeColor','none','Parent',Handles.(Subs{ST}),'ButtonDownFcn',@(src,evt)SelectWindow(src,evt),'Tag',num2str(x)),1:numel(RemovedWindows(:,1)));
            uistack( Handles.FillRemovedWindows.(Subs{ST}),'bottom')
        end
    end


    function SelectWindow(src,~)
        if Selected == str2double(src.Tag),
            Selected = [];
            Colors = repmat({[0.85 0.85 0.9]},numel(RemovedWindows(:,1)),1);
            LineColors = repmat({[1 1 1]},numel(RemovedWindows(:,1)),1);
            for S = 1 : numel(Subs),
                set(Handles.FillRemovedWindows.(Subs{S}),{'FaceColor'},Colors)
                set(Handles.FillRemovedWindows.(Subs{S}),{'EdgeColor'},LineColors)
            end
        else
            Selected = str2double(src.Tag);
            Colors = repmat({[0.85 0.85 0.9]},numel(RemovedWindows(:,1)),1);
            LineColors = repmat({[1 1 1]},numel(RemovedWindows(:,1)),1);
            Colors(Selected,:) = {[0.5 0.85 0.94]};
            LineColors(Selected,:) = {[0 0 0]};
            for S = 1 : numel(Subs),
                set(Handles.FillRemovedWindows.(Subs{S}),{'FaceColor'},Colors)
                set(Handles.FillRemovedWindows.(Subs{S}),{'EdgeColor'},LineColors)
            end
        end
    end


    function DeleteRangeCB(~,~)
        if ~isempty(Selected)
            RemovedWindows(Selected,:) = [];
            for ST = 1 : numel(Subs)
                delete( Handles.FillRemovedWindows.(Subs{ST}))
                Handles.FillRemovedWindows.(Subs{ST}) = arrayfun(@(x) fill([RemovedWindows(x,1) RemovedWindows(x,2) RemovedWindows(x,2) RemovedWindows(x,1)], [ Handles.Min.(Subs{ST})   Handles.Min.(Subs{ST})   Handles.Max.(Subs{ST})   Handles.Max.(Subs{ST})],[0.85 0.85 0.9],'EdgeColor','none','Parent',Handles.(Subs{ST}),'ButtonDownFcn',@(src,evt)SelectWindow(src,evt),'Tag',num2str(x)),1:numel(RemovedWindows(:,1)));
                uistack( Handles.FillRemovedWindows.(Subs{ST}),'bottom')
            end
        end
        Selected = [];
    end


    function TimeLine(~,~)
        if ~Dragging
            PrePlayState = Play;
            Play = false;
            Dragging = true;
            Fig.WindowButtonMotionFcn = @MovingTimeLine;
            Fig.WindowButtonUpFcn = @TimeLine;
        else
            Dragging = false;
            Fig.WindowButtonMotionFcn = [];
            Fig.WindowButtonUpFcn = [];
            Play = PrePlayState;
            PlayMovie;
        end
    end


    function MovingTimeLine(~,~)
        if UpToDate
            UpToDate = false;
            CurrentCursor = Handles.SubMM.CurrentPoint;
            if CurrentCursor(1)>=0 && CurrentCursor(1)<=Times(end),
                if CurrentCursor(1) >= Handles.SubMM.XLim(2),
                    NewY = Handles.SubMM.XLim(2) + 0.025*diff( Handles.SubMM.XLim);
                    if NewY<=Times(end),
                        Handles.SubMM.XLim = Handles.SubMM.XLim + 0.025*diff( Handles.SubMM.XLim);
                    else
                        Handles.SubMM.XLim = Handles.SubMM.XLim+(Times(end)-SubMM.XLim(2));
                    end
                    CurrentTime = Handles.SubMM.XLim(2);
                elseif CurrentCursor(1) <= Handles.SubMM.XLim(1),
                    NewY = Handles.SubMM.XLim(1) - 0.025*diff( Handles.SubMM.XLim);
                    if NewY<=Times(end),
                        Handles.SubMM.XLim = Handles.SubMM.XLim - 0.025*diff( Handles.SubMM.XLim);
                    else
                        Handles.SubMM.XLim = Handles.SubMM.XLim - ( Handles.SubMM.XLim(1));
                    end
                    CurrentTime = Handles.SubMM.XLim(1);
                else
                    CurrentTime = CurrentCursor(1);
                end
            end
            LineCurrentTime.XData = [CurrentTime CurrentTime];
            FrameUpdate;
        end
    end

    function FrameUpdate(~,~)
        NewIndex = FindInInterval(Times,[CurrentTime CurrentTime]);
        %         if ~OnlineReading,
        %             ImFrame.CData = Frames{NewIndex(1)};
        %         else
        ContourPlot.XData = Contour{NewIndex(1)}(1,:);
        ContourPlot.YData = Contour{NewIndex(1)}(2,:);
        CenterPlot.XData = Center_GF(NewIndex(1),1);
        CenterPlot.YData = Center_GF(NewIndex(1),2);
        if NewIndex(1)>1
            Frame0.CurrentTime = FrameTimes(NewIndex(1)-1);
        else
            Frame0.CurrentTime = FrameTimes(NewIndex(1));
        end
        if strcmpi(MovieType,'Thermal'),
            TempFrame = Frame0.readFrame;
            ImFrame.CData = TempFrame(:,:,1);
        else
            ImFrame.CData = (Frame0.readFrame);
        end
        TimeText.String = num2str(Times(NewIndex(1)));
        %         end
        uistack(SpeedText,'top')
        drawnow
        UpToDate = true;
    end

    function EvaluateWindow(~,~)
        PrePlayState = Play;
        Play = false;
        if Handles.SubMM.XLim(1)<0,
            Handles.SubMM.XLim(1) = 0;
        elseif Handles.SubMM.XLim(2)>Times(end),
            Handles.SubMM.XLim(2) = Times(end);
        end
        if CurrentTime<Handles.SubMM.XLim(1) || CurrentTime>Handles.SubMM.XLim(2),
            CurrentTime = Handles.SubMM.XLim(1) + 0.5*diff( Handles.SubMM.XLim);
            LineCurrentTime.XData = [CurrentTime CurrentTime];
            FrameUpdate;
        end
        Play = PrePlayState;
        PlayMovie;
    end

    function PlayMovie(~,~)

        if Play
            % Only approximate framerate (for faster plotting)
            CurrentTime = CurrentTime+1/FrameRate;

            % Plot once to get a starting value for the delay
            tic
            %             if ~OnlineReading,
            %                 ImFrame.CData = Frames{CurrentIndex(1)};
            %             else
            CurrentIndex = FindInInterval(Times,[CurrentTime CurrentTime]);
            ContourPlot.XData = Contour{CurrentIndex(1)}(1,:);
            ContourPlot.YData = Contour{CurrentIndex(1)}(2,:);
            CenterPlot.XData = Center_GF(CurrentIndex(1),1);
            CenterPlot.YData = Center_GF(CurrentIndex(1),2);
            Frame0.CurrentTime = FrameTimes(CurrentIndex(1)-1);
            if strcmpi(MovieType,'Thermal'),
                TempFrame = Frame0.readFrame;
                ImFrame.CData = TempFrame(:,:,1);
            else
                ImFrame.CData = (Frame0.readFrame);
            end
            TimeText.String = num2str(Times(CurrentIndex(1)));
            %             end
            uistack(SpeedText,'top')
            LineCurrentTime.XData = [Times(CurrentIndex(1)) Times(CurrentIndex(1))];
            drawnow
        end
        while Play
            TocT = toc;
            EstimatedShift = TocT*FrameRate;
            if EstimatedShift>1
                tic;
                CurrentIndex = CurrentIndex + round(EstimatedShift);
                CurrentTime = Times(CurrentIndex(1));
                %                 if ~OnlineReading,
                %                     ImFrame.CData = Frames{CurrentIndex(1)};
                %                 else
                if strcmpi(MovieType,'Thermal'),
                    TempFrame = Frame0.readFrame;
                    ImFrame.CData = TempFrame(:,:,1);
                else
                    ImFrame.CData = (Frame0.readFrame);
                end
                ContourPlot.XData = Contour{CurrentIndex(1)}(1,:);
                ContourPlot.YData = Contour{CurrentIndex(1)}(2,:);
                CenterPlot.XData = Center_GF(CurrentIndex(1),1);
                CenterPlot.YData = Center_GF(CurrentIndex(1),2);
                Frame0.CurrentTime = FrameTimes(CurrentIndex(1));
                TimeText.String = num2str(Times(CurrentIndex(1)));
%                 uistack(SpeedText,'top')
                LineCurrentTime.XData = [CurrentTime CurrentTime];
                if CurrentTime>=( Handles.SubMM.XLim(2)-ShiftTimeLine*diff( Handles.SubMM.XLim))
                    Handles.SubMM.XLim = Handles.SubMM.XLim + CurrentTime-SubMM.XLim(2)+ShiftTimeLine*diff(Handles.SubMM.XLim);
                end
                drawnow

            end
        end
    end

    function PauseMovie(~,~)
        Play = false;
    end

    function EditThreshold(src,~)
    end

    function EditThresholdSet(~,~)
        if str2double(ThresholdEdit.String)>0,
            ThresholdMM = str2double(ThresholdEdit.String);
            ThresholdLine.Color = 'none';
            ThresholdLine.ButtonDownFcn = [];
            ReProcessFreezing;
        end
    end

    function DragThreshold(~,~)
        ThresholdLine.Color = [0.85,0.33,0.10];
        ThresholdLine.ButtonDownFcn = @StartDragThreshold;
        uistack(ThresholdLine,'top')
        Play = false;
        Dragging = false;
    end

    function StartDragThreshold(~,~)
        if ~Dragging
            Fig.WindowButtonMotionFcn = @MovingThresholdLine;
            Fig.WindowButtonUpFcn = @StartDragThreshold;
            Dragging = true;
        else
            Dragging = false;
            Fig.WindowButtonMotionFcn = [];
            Fig.WindowButtonUpFcn = [];
        end
    end

    function MovingThresholdLine(~,~)
        CurrentCursor = Handles.SubMM.CurrentPoint;
        if CurrentCursor(1,2)>=0 && CurrentCursor(1,2)<=Handles.SubMM.YLim(2),
            ThresholdLine.YData = [CurrentCursor(1,2) CurrentCursor(1,2)];
            ThresholdEdit.String = num2str(CurrentCursor(1,2));
            drawnow;
        end
    end

    function MergeEditThreshold(~,~)
    end

    function MergeEditThresholdSet(~,~)
        if str2double(MergeThresholdEdit.String)>=0,
            MergeThreshold = str2double(MergeThresholdEdit.String);
            ReProcessFreezing;
        end
    end

    function EditMinEpisode(~,~)
    end

    function EditMinEpisodeSet(~,~)
        if str2double(MinEpisodeEdit.String)>0,
            FreezingMinTime = str2double(MinEpisodeEdit.String);
            ReProcessFreezing;
        end
    end

    function ReProcessFreezing(~,~)
        FindIndex = find(Smooth(MotionMeasure,SmoothMM)<ThresholdMM);
        FreezingEpisodes = FindContinuousRange(FindIndex);
        FreezingEpisodes = FindIndex(FreezingEpisodes(:,[1 2]));
        FreezingEpisodes = Times(FreezingEpisodes);

        % Merging
        for KFS = 2 : numel(FreezingEpisodes(:,1))
            if (FreezingEpisodes(KFS,1)-FreezingEpisodes(KFS-1,2))<MergeThreshold,
                FreezingEpisodes(KFS,1) = FreezingEpisodes(KFS-1,1);
                FreezingEpisodes(KFS-1,:) = NaN(1,2);
            end
        end
        FreezingEpisodes = FreezingEpisodes(~isnan(FreezingEpisodes(:,1)),:);

        FreezingEpisodesLength = (FreezingEpisodes(:,2)-FreezingEpisodes(:,1));
        FreezingEpisodes(FreezingEpisodesLength<=FreezingMinTime,:) = [];

        OriginalEpisodes = FreezingEpisodes;
        delete(FreezingHandles(:));
        FreezingHandles = arrayfun(@(x) plot([FreezingEpisodes(x,1) FreezingEpisodes(x,2)],[0 0],'k','LineWidth',3,'Parent', Handles.SubFreezing,'Tag',num2str(x),'ButtonDownFcn',@FreezingEdit),1:numel(FreezingEpisodes(:,1)));
        Handles.SubFreezing.XColor = 'none';
        Handles.SubFreezing.YColor = 'none';
        Handles.SubFreezing.YLim = [-0.5 0.5];
    end



    function Exit(~,~)
        Play = false;
        FreezingEpisodes(DeletionIndex,:) = [];
        % Add to logfile
        Tracking.(MovieType).Freezing.MotionMeasureThreshold = ThresholdMM;
        Tracking.(MovieType).Freezing.MergingThreshold = MergeThreshold;
        Tracking.(MovieType).Freezing.Duration = FreezingMinTime;
        Tracking.(MovieType).Freezing.Smoothing = SmoothMM;
        Tracking.(MovieType).Freezing.Ranges = FreezingEpisodes;
        Tracking.(MovieType).RemovedRanges= RemovedWindows;
        save(TrackingLog,'-struct','Tracking')
        close(Fig)
    end


end
